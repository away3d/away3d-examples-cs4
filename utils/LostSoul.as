package utils{		import away3d.sprites.*;	import away3d.core.base.*;	import away3d.core.utils.*;	import away3d.events.*;	import away3d.materials.*;		import flash.display.*;		/**	 * Class for creating moving lost soul sprite	 */	public class LostSoul extends Mesh	{		private var _dirSprite:DirectionalSprite = new DirectionalSprite();		private var _role:String;		private var _nextthink:int;		private var _lastmove:int;				/**		 * Constructor		 */		public function LostSoul(material1:Material, material2:Material, material3:Material, material4:Material, material5:Material, material6:Material, material7:Material, material8:Material)		{			super();						addSprite(_dirSprite);						_dirSprite.scaling = 2;						_dirSprite.addDirectionalMaterial(new Vertex(0   , 0,-1  ), material1);			_dirSprite.addDirectionalMaterial(new Vertex(-0.7, 0,-0.7), material2);			_dirSprite.addDirectionalMaterial(new Vertex(-1  , 0, 0  ), material3);			_dirSprite.addDirectionalMaterial(new Vertex(-0.7, 0, 0.7), material4);			_dirSprite.addDirectionalMaterial(new Vertex( 0  , 0, 1  ), material5);			_dirSprite.addDirectionalMaterial(new Vertex( 0.7, 0, 0.7), material6);			_dirSprite.addDirectionalMaterial(new Vertex( 1  , 0, 0  ), material7);			_dirSprite.addDirectionalMaterial(new Vertex( 0.7, 0,-0.7), material8);		}				/**		 * Updates every frame		 */		public override function tick(time:int):void		{			if ((_role == null) || (_nextthink < time)) {				_role = (["stop", "right", "left", "forward"])[int(Math.random()*4)];				if ((Math.abs(x) > 300) || (Math.abs(z) > 300))					_role = "right";				//_role = (["right", "left"])[int(Math.random()*2)];				_nextthink = time + Math.random()*3000;			}						var delta:Number = (_lastmove - time)/1000;						switch (_role) {				case "stop":					rotationY += delta*(Math.random()*20-10);					break;				case "right":					rotationY += delta*Math.random()*10; moveForward(delta*20);					break;				case "left":					rotationY -= delta*Math.random()*10; moveForward(delta*20);					break;				case "forward":					moveForward(delta*60);					break;				default:			}						_lastmove = time;						//constrain position			if (x > 500)				x = 500;			if (x < -500)				x = -500;			if (z > 500)				z = 500;			if (z < -500)				z = -500;		}	}}